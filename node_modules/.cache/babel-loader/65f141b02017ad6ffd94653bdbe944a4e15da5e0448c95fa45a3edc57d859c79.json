{"ast":null,"code":"useEffect(() => {\n  let intervalId;\n  if (isRunning) {\n    if (!startTimeRef.current) {\n      startTimeRef.current = Date.now() - elapsedTime * 1000;\n    }\n    intervalId = setInterval(() => {\n      const currentTime = Date.now();\n      const elapsedSeconds = Math.floor((currentTime - startTimeRef.current) / 1000);\n      dashOffset.current = dashOffset.current - circumference / totalTime;\n\n      // Update elapsed time when the animation is in progress\n      if (elapsedSeconds <= totalTime) {\n        setElapsedTime(elapsedSeconds);\n      } else {\n        // Timer completed, reset start time\n        startTimeRef.current = null;\n      }\n    }, 1000);\n  } else {\n    // Reset dashOffset when not running\n    dashOffset.current = circumference;\n\n    // If elapsed time is greater than zero, set start time to the elapsed seconds\n    if (elapsedTime > 0) {\n      startTimeRef.current = Date.now() - elapsedTime * 1000;\n    } else {\n      // Reset start time\n      startTimeRef.current = null;\n    }\n  }\n  return () => clearInterval(intervalId);\n}, [isRunning, totalTime, circumference, elapsedTime]);","map":{"version":3,"names":["useEffect","intervalId","isRunning","startTimeRef","current","Date","now","elapsedTime","setInterval","currentTime","elapsedSeconds","Math","floor","dashOffset","circumference","totalTime","setElapsedTime","clearInterval"],"sources":["/home/sc/pomodoro-clock/pomo-clock-frontend/pomodoro-clock-app/src/components/SessionTimer.js"],"sourcesContent":["useEffect(() => {\n    let intervalId;\n\n    if (isRunning) {\n        if (!startTimeRef.current) {\n            startTimeRef.current = Date.now() - elapsedTime * 1000;\n        }\n\n        intervalId = setInterval(() => {\n            const currentTime = Date.now();\n            const elapsedSeconds = Math.floor((currentTime - startTimeRef.current) / 1000);\n            dashOffset.current = dashOffset.current - (circumference / totalTime);\n\n            // Update elapsed time when the animation is in progress\n            if (elapsedSeconds <= totalTime) {\n                setElapsedTime(elapsedSeconds);\n            } else {\n                // Timer completed, reset start time\n                startTimeRef.current = null;\n            }\n        }, 1000);\n    } else {\n        // Reset dashOffset when not running\n        dashOffset.current = circumference;\n\n        // If elapsed time is greater than zero, set start time to the elapsed seconds\n        if (elapsedTime > 0) {\n            startTimeRef.current = Date.now() - elapsedTime * 1000;\n        } else {\n            // Reset start time\n            startTimeRef.current = null;\n        }\n    }\n\n    return () => clearInterval(intervalId);\n}, [isRunning, totalTime, circumference, elapsedTime]);\n"],"mappings":"AAAAA,SAAS,CAAC,MAAM;EACZ,IAAIC,UAAU;EAEd,IAAIC,SAAS,EAAE;IACX,IAAI,CAACC,YAAY,CAACC,OAAO,EAAE;MACvBD,YAAY,CAACC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGC,WAAW,GAAG,IAAI;IAC1D;IAEAN,UAAU,GAAGO,WAAW,CAAC,MAAM;MAC3B,MAAMC,WAAW,GAAGJ,IAAI,CAACC,GAAG,CAAC,CAAC;MAC9B,MAAMI,cAAc,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACH,WAAW,GAAGN,YAAY,CAACC,OAAO,IAAI,IAAI,CAAC;MAC9ES,UAAU,CAACT,OAAO,GAAGS,UAAU,CAACT,OAAO,GAAIU,aAAa,GAAGC,SAAU;;MAErE;MACA,IAAIL,cAAc,IAAIK,SAAS,EAAE;QAC7BC,cAAc,CAACN,cAAc,CAAC;MAClC,CAAC,MAAM;QACH;QACAP,YAAY,CAACC,OAAO,GAAG,IAAI;MAC/B;IACJ,CAAC,EAAE,IAAI,CAAC;EACZ,CAAC,MAAM;IACH;IACAS,UAAU,CAACT,OAAO,GAAGU,aAAa;;IAElC;IACA,IAAIP,WAAW,GAAG,CAAC,EAAE;MACjBJ,YAAY,CAACC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGC,WAAW,GAAG,IAAI;IAC1D,CAAC,MAAM;MACH;MACAJ,YAAY,CAACC,OAAO,GAAG,IAAI;IAC/B;EACJ;EAEA,OAAO,MAAMa,aAAa,CAAChB,UAAU,CAAC;AAC1C,CAAC,EAAE,CAACC,SAAS,EAAEa,SAAS,EAAED,aAAa,EAAEP,WAAW,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}